#include <iostream>
#include <cstring>
#include <thread>
#include <atomic>
#include <droidCrypto/ChannelWrapper.h>
#include <droidCrypto/gc/circuits/AESCircuit.h>
#include <droidCrypto/BitVector.h>
#include <droidCrypto/utils/Log.h>
#include <assert.h>

std::atomic_flag ready;

#define NUM_AES 5535
int main(int argc, char** argv) {

    std::thread server([]{
        //server
        droidCrypto::CSocketChannel chan("127.0.0.1", 8000, true);

        uint8_t AES_TEST_EXPANDED_KEY[AES_EXP_KEY_BYTES] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x63, 0x63, 0x63,
                                                             0x62, 0x63, 0x63, 0x63, 0x62, 0x63, 0x63, 0x63, 0x62, 0x63, 0x63, 0x63, 0x9b, 0x98, 0x98, 0xc9, 0xf9, 0xfb, 0xfb, 0xaa, 0x9b, 0x98, 0x98, 0xc9, 0xf9, 0xfb, 0xfb, 0xaa,
                                                             0x90, 0x97, 0x34, 0x50, 0x69, 0x6c, 0xcf, 0xfa, 0xf2, 0xf4, 0x57, 0x33, 0x0b, 0x0f, 0xac, 0x99, 0xee, 0x06, 0xda, 0x7b, 0x87, 0x6a, 0x15, 0x81, 0x75, 0x9e, 0x42, 0xb2,
                                                             0x7e, 0x91, 0xee, 0x2b, 0x7f, 0x2e, 0x2b, 0x88, 0xf8, 0x44, 0x3e, 0x09, 0x8d, 0xda, 0x7c, 0xbb, 0xf3, 0x4b, 0x92, 0x90, 0xec, 0x61, 0x4b, 0x85, 0x14, 0x25, 0x75, 0x8c,
                                                             0x99, 0xff, 0x09, 0x37, 0x6a, 0xb4, 0x9b, 0xa7, 0x21, 0x75, 0x17, 0x87, 0x35, 0x50, 0x62, 0x0b, 0xac, 0xaf, 0x6b, 0x3c, 0xc6, 0x1b, 0xf0, 0x9b, 0x0e, 0xf9, 0x03, 0x33,
                                                             0x3b, 0xa9, 0x61, 0x38, 0x97, 0x06, 0x0a, 0x04, 0x51, 0x1d, 0xfa, 0x9f, 0xb1, 0xd4, 0xd8, 0xe2, 0x8a, 0x7d, 0xb9, 0xda, 0x1d, 0x7b, 0xb3, 0xde, 0x4c, 0x66, 0x49, 0x41,
                                                             0xb4, 0xef, 0x5b, 0xcb, 0x3e, 0x92, 0xe2, 0x11, 0x23, 0xe9, 0x51, 0xcf, 0x6f, 0x8f, 0x18, 0x8e };
        droidCrypto::BitVector a(AES_TEST_EXPANDED_KEY, AES_EXP_KEY_BITS);
        droidCrypto::SIMDAESCircuit circ(chan);
        circ.garble(a, NUM_AES);
        droidCrypto::Log::v("GC", "GARBLER: bytes sent: %zu, recv: %zu", chan.getBytesSent(), chan.getBytesRecv());

    });
    //client
    std::this_thread::sleep_for(std::chrono::milliseconds(20));
    droidCrypto::CSocketChannel chan("127.0.0.1", 8000, false);
    std::this_thread::sleep_for(std::chrono::milliseconds(5000));

    uint8_t AES_TEST_INPUT[AES_BYTES] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff };
    droidCrypto::BitVector a(AES_TEST_INPUT, AES_BYTES*8);
    std::vector<droidCrypto::BitVector> aa(NUM_AES, a);

    droidCrypto::SIMDAESCircuit circ(chan);
    std::vector<droidCrypto::BitVector> ct = circ.evaluate(aa);
    std::string time = "Time: " + std::to_string(circ.timeBaseOT.count());
    time += ", " + std::to_string(circ.timeOT.count());
    time += ", " + std::to_string(circ.timeEval.count());
    time += ", " + std::to_string(circ.timeOutput.count());
    droidCrypto::Log::v("GC", "%s", time.c_str());
    droidCrypto::block tmpa;
    memcpy(&tmpa, ct[0].data(), sizeof(droidCrypto::block));
    droidCrypto::Log::v("GC", tmpa);
    assert(ct[0].hex() == std::string("c8a331ff8edd3db175e1545dbefb760b"));

    droidCrypto::Log::v("GC", "bytes sent: %zu, recv: %zu", chan.getBytesSent(), chan.getBytesRecv());


    server.join();
    return 0;
}
